1-1. Репозитарий Git должен быть устроен так, чтобы его содержимого было 
достаточно для компиляции проекта и его запуска. Но при этом не должно 
быть ничего лишнего. 

Отсюда выводы:
- для проекта в Eclipse в Git попадают:
  - каталог src (и иные каталоги с исходниками, если таковые есть)
  - файлы .classpath, .project и подобные с настройками проекта
При этом каталог bin в Git не вкладывается (там находятся 
откомпилированные файлы, которые можно всегда скомпилировать из 
исходников)
  - каталог .idea, кажется, можно оставить в Git, поскольку там лежат 
  настройки проекта для Idea.

- желательно иметь скрипт (cmd/bat для Windows или sh/bash для Linux), 
который умеет собирать программу без использования Eclipse.

1-2. В base.mbd слово "овощ" нужно писать без мягкого знака. :)

1-3. Привыкайте к тому, что в программе не должно быть вечных циклов 
(см. MixBot.main). Всегда должен быть флаг, контролирующий завершение 
цикла (в случае бота в какой-то момент этот флаг будет использоваться, 
например, для перезапуска бота через интерфейс администрирования).

1-4. В текущем master-е в Git у вас сейчас находится "битая" версия 
исходников (см., напр., BasketDialog.java, в котором видим следы 
незаконченного слияния (merge) веток проекта). Надо починить. И научиться 
правильно делать слияние, чтобы итоговая версия была корректной.
К слову, я всегда смотрю состояние ветки master, вне зависимости от того, 
что творится в других ветках.

1-5. В BasketDialog для анализа слов используется такой код:
        for (String word : words) {
            if (endWords.contains(word)) {
Но операция contains на списках является медленной. Лучше в этом случае 
использовать не списки (ArrayList), а множества (HashSet), для которых эта 
операция является быстрой (O(1)).

1-6. В BasketDialos видим такие строчки:
new Response(elseWords.get(random.nextInt(2) + 2));
Почему здесь явно появились двойки в виде констант?  А если набор записей 
в elseWords изменится? Так что такой код я обычно считаю ошибочным (по 
причине его хрупкости). 

1-7. В BasketDialog видим классическую ошибку при работе с хэш-таблицами:
            if (MixBot.ingredients.containsKey(ing))
                ingredients.add(MixBot.ingredients.get(ing));
Тут поиск в таблице делается дважды (методы contains и get). А зачем?
Ведь достаточно попытаться получить ингредиент методом get, а затем 
проверить результат на null, и если он не null, то добавлять его в список 
ingredients.

И затем эта ошибка еще раз повторяется:
                if (possibleFood.containsKey(food.name))
                    possibleFood.get(food.name).checkList.put(ing, true);


1-8. В FileWorker привыкаем работу с файлами оформлять так:
        try (FileReader fr = new FileReader(fileName))
        {
          <здесь работаем с fr>
        }
В противном случае есть риск получить ситуацию, когда файл будет 
недоступен для чтения при конкуретной работе (я буду об этом рассказывать 
на лекциях в ближайшее время).


1-9. Класс Ingredient используется в качестве ключа в отображении 
(HashMap). В таких случаях:
- сам класс крайне желательно спроектировать как неизменный
- нужно определить equals и hashcode
